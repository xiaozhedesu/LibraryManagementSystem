# LibraryManagementSystem

## 前言 

图书管理系统，虽然已经被大家写烂了，但是它被这么多人写一定有它的原因。

最近读教材已经读晕了，因为Java的特性这么多，看了也不一定真记住了，还是需要自己做项目练熟练的。xx系统可以将后端（java）、前端（vue3）和数据库（mysql）连接在一起，是很好的练习材料。

目前打算自己写一个图书管理系统出来，从命令行控制开始，到使用vue写一个简约的页面为止，将以上三个技术栈至少学到能用的程度。

2025年10月8日

## log

### 2025年10月22日

本来我是打算完成第一版就去研究如何与web前端对接的，但是我在图书馆借到了一本《大话设计模式》，看了一点之后顿感我之前的后端代码还不够成熟，于是又转头先打磨我的后端代码了。更别说我才知道数据库操作可以提炼出一个模板方法，第一版即便是整理了代码也还是太过啰嗦。

现在它的结构变成了以下这样：

- **cli\\** 控制台程序
  - **Main**：程序入口
  - **OPHandler**：操作请求/响应的集中处理器
- **dao\\**：
    - **JDBCActuator**：负责实际 JDBC 执行的小工具
- **exception**：自定义异常类
- **model\\**：
    - **Book**：图书实体
- **service\\**：
    - **BooksService**：图书业务逻辑
- **strategy\\**：
    - **book\\**：图书策略实现
    - **SQLStrategy**：SQL策略接口
- **support\\**：
    - **BookResultSetHandler**：把 ResultSet 转成 Book 的助手
    - **HelpMessage**：help信息
    - **ResultSetHandler**：通用结果集处理接口
    - **Utils**：工具类

改变之后每当想新增一个图书策略，只要在`strategy.book`里新写一个类继承`SQLStrategy`，然后在枚举类新增一条常量就完成添加、不需要改动其他代码了。

而且即便转型至web前端、只要后端接口不做变动，`cli`的代码也能保留，设计模式真是个好东西😋。

### 2025年10月16日

第一版基本完成，我对它的定位是使用命令行互动的系统。提供`help`指令用来查询语句，还支持一部分CRUD操作，分为了`search`、`add`、`change`、`delete`四个指令。除了`add`指令只支持信息全输入操作以外，其他三个指令都有分指令，可以查看`HelpMesasge`类了解目前支持的指令。

关于这个项目代码的大体结构：它由`Main`类做入口、完成初始化、连接数据库、开启循环接收指令等操作。`OPHandler`对象处理输入的指令，这个对象持有一个`Library`对象，它统领CRUD的全部操作。由于代码太长，我将数量多的操作函数分成三份，分别放在`LibrarySelector`、`LibraryDeleter`、`LibraryChanger`中。`add`因为只有一个函数，所以不必拆分，直接放在`Library`中，`Library`持有其他三个类的对象，从而能使用相对应的数据库指令。包中类使用到的工具函数基本都封装在了`Utils`类中。`Book`类是用来打包数据的，代码中还贴有Books数据表的约束。

异常处理：`Main`类和`OPHandler`对象作为前端，负责捕获异常并输出，`OPHandler`对象中的异常不影响整个系统运行，不需要终止系统，而`Main`类中的异常如果触发了会导致系统运行异常，所以我选择了直接打印堆栈信息或者抛出运行时异常，终止程序。其他类都是作为后端使用，在这些类中的异常会直接抛出，在前端进行处理。抛出的异常中不仅有`SQLException`，还有方便处理的自定义异常`BookBusinessException`，当出现业务逻辑上的错误时，它会被抛出。在exception包中，还有其他的自定义异常，它们对应特定情况的异常，都继承了`BookBusinessException`异常类，这样前端只需要捕获这个大类，错误信息会借助多态而细化打印，使代码更简洁。

技术债：
1. 时间使用了字符串保存，要求格式为`YYYY-MM-DD`，这不是一个好选择，但是建表的时候我还不熟悉数据库的时间类型，下版本会修正。
2. 当使用add方法添加书籍信息的时候，id采用的生成策略是使用标题的`hashCode`，下个版本会重新建表，将id设置为自增主键。